<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Galaga - Complete with Sound</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: Courier, monospace;
    }
    #gameCanvas {
      border: 2px solid #0f0;
      background: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #0f0;
      font-size: 20px;
    }
    #controls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #0f0;
      font-size: 14px;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #f00;
      font-size: 32px;
      text-align: center;
      display: none;
    }
  </style>
</head>
<body>
  <div id="info">SCORE: <span id="score">0</span> | LIVES: <span id="lives">3</span> | LEVEL: <span id="level">1</span></div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="controls">ARROW KEYS: Move | SPACE: Fire | R: Restart</div>
  <div id="gameOver">GAME OVER<br /><small>Press R to restart</small></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let score = 0, lives = 3, level = 1;
let bullets = [], enemyBullets = [], enemies = [], explosions = [];
let keys = {}, lastShot = 0, enemyMoveTimer = 0, diveTimer = 0, enemyShootTimer = 0;
let canControl = false, respawnTimer = 0, gameRunning = true;

const player = { x: 0, y: 0, w: 40, h: 30, speed: 6, color: '#0f0' };

let soundPools = {};
function loadSound(name, path, poolSize = 5) {
  soundPools[name] = [];
  for (let i = 0; i < poolSize; i++) {
    const audio = new Audio(path);
    audio.preload = 'auto';
    soundPools[name].push(audio);
  }
}
function playSound(name) {
  const pool = soundPools[name];
  if (!pool) return;
  for (const audio of pool) {
    if (audio.paused || audio.ended) {
      audio.currentTime = 0;
      audio.volume = 0.5;
      audio.play().catch(() => {});
      break;
    }
  }
}

function initSounds() {
  loadSound('shoot', 'sounds/shoot.wav');
  loadSound('playerExplode', 'sounds/player-explode.wav');
  loadSound('enemyDive', 'sounds/enemy-dive.wav');
}

function createExplosion(x, y, color = '#f00', count = 15) {
  for (let i = 0; i < count; i++) {
    explosions.push({
      x, y,
      dx: (Math.random() - 0.5) * 5,
      dy: (Math.random() - 0.5) * 5,
      life: 30,
      color
    });
  }
}

function updateExplosions() {
  explosions = explosions.filter(e => e.life > 0);
  explosions.forEach(e => { e.x += e.dx; e.y += e.dy; e.life--; });
}

function drawExplosions() {
  explosions.forEach(e => {
    ctx.fillStyle = e.color;
    ctx.fillRect(e.x, e.y, 3, 3);
  });
}

function createEnemies() {
  enemies = [];
  const setups = [
    { rows: 2, cols: 8, y0: 50, type: 'boss', color: '#4080ff', pts: 400 },
    { rows: 2, cols: 10, y0: 100, type: 'red', color: '#f44', pts: 160 },
    { rows: 4, cols: 10, y0: 150, type: 'yellow', color: '#ff0', pts: 80 }
  ];
  setups.forEach(f => {
    for (let r = 0; r < f.rows; r++) {
      for (let c = 0; c < f.cols; c++) {
        let x = 100 + c * 60, y = f.y0 + r * 40;
        enemies.push({
          x, y, ox: x, oy: y, w: 30, h: 25,
          color: f.color, pts: f.pts, shootChance: 0.0015,
          alive: true, diving: false, diveAngle: 0, diveSpeed: 0
        });
      }
    }
  });
}

function startRespawn() {
  canControl = false;
  respawnTimer = 120;
  bullets = [];
  enemyBullets = [];
  player.x = canvas.width / 2 - player.w / 2;
  player.y = canvas.height - 60;
  enemies.forEach(e => { if (e.alive) { e.x = e.ox; e.y = e.oy; e.diving = false; }});
}

function shoot() {
  if (!canControl || Date.now() - lastShot < 200) return;
  lastShot = Date.now();
  bullets.push({ x: player.x + 18, y: player.y, w: 4, h: 10, sp: 8, color: '#fff' });
  playSound('shoot');
}

function updateEnemyDiving() {
  diveTimer++;
  if (diveTimer > 240 && Math.random() < 0.01) {
    const pool = enemies.filter(e => e.alive && !e.diving);
    if (pool.length) {
      let d = pool[Math.floor(Math.random() * pool.length)];
      d.diving = true;
      d.diveSpeed = 1.5;
      d.diveAngle = Math.random() * Math.PI / 3 - Math.PI / 6;
      playSound('enemyDive');
    }
  }
  enemies.forEach(e => {
    if (e.alive && e.diving) {
      e.x += Math.sin(e.diveAngle) * e.diveSpeed;
      e.y += e.diveSpeed;
      if (e.y > canvas.height + 50) {
        e.diving = false;
        e.x = e.ox; e.y = e.oy;
      }
    }
  });
}

function update() {
  if (!gameRunning) return;
  if (respawnTimer > 0) { respawnTimer--; return; } else { canControl = true; }

  if (keys['ArrowLeft']) player.x = Math.max(0, player.x - player.speed);
  if (keys['ArrowRight']) player.x = Math.min(canvas.width - player.w, player.x + player.speed);

  bullets = bullets.filter(b => {
    b.y -= b.sp;
    for (let e of enemies) {
      if (e.alive && b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
        e.alive = false;
        score += e.pts;
        createExplosion(e.x + e.w / 2, e.y + e.h / 2, '#f80');
        return false;
      }
    }
    return b.y + b.h > 0;
  });

  enemyBullets = enemyBullets.filter(b => {
    b.y += b.sp;
    if (b.x < player.x + player.w && b.x + b.w > player.x && b.y < player.y + player.h && b.y + b.h > player.y) {
      playerDies();
      return false;
    }
    return b.y < canvas.height;
  });

  for (let e of enemies) {
    if (e.alive && e.x < player.x + player.w && e.x + e.w > player.x && e.y < player.y + player.h && e.y + e.h > player.y) playerDies();
  }

  enemies.forEach(e => {
    if (e.alive && !e.diving && Math.random() < e.shootChance) {
      enemyBullets.push({ x: e.x + e.w / 2 - 2, y: e.y + e.h, w: 4, h: 8, sp: 3, color: '#f44' });
    }
  });

  updateEnemyDiving();
  updateExplosions();

  if (!enemies.some(e => e.alive)) {
    level++;
    createEnemies();
    startRespawn();
  }
}

function drawPlayer() {
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x + 8, player.y + 15, 24, 15);
  ctx.fillStyle = '#80ff80';
  ctx.fillRect(player.x + 16, player.y + 12, 8, 8);
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y + 20, 8, 8);
  ctx.fillRect(player.x + 32, player.y + 20, 8, 8);
  ctx.fillRect(player.x + 16, player.y + 8, 8, 8);
  ctx.fillStyle = '#ffff80';
  ctx.fillRect(player.x + 12, player.y + 28, 4, 2);
  ctx.fillRect(player.x + 24, player.y + 28, 4, 2);
  ctx.fillStyle = '#fff';
  ctx.fillRect(player.x + 4, player.y + 20, 2, 2);
  ctx.fillRect(player.x + 34, player.y + 20, 2, 2);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPlayer();
  bullets.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.w, b.h); });
  enemyBullets.forEach(b => { ctx.fillStyle = b.color; ctx.fillRect(b.x, b.y, b.w, b.h); });
  enemies.forEach(e => {
    if (!e.alive) return;
    ctx.fillStyle = e.color;
    ctx.fillRect(e.x, e.y, e.w, e.h);
  });
  drawExplosions();
}

function playerDies() {
  if (!canControl) return;
  createExplosion(player.x + player.w / 2, player.y + player.h / 2, '#ff0', 40);
  playSound('playerExplode');
  lives--;
  updateInfo();
  bullets = [];
  enemyBullets = [];
  if (lives > 0) startRespawn();
  else {
    canControl = false;
    gameRunning = false;
    document.getElementById('gameOver').style.display = 'block';
  }
}

function updateInfo() {
  document.getElementById('score').textContent = score;
  document.getElementById('lives').textContent = lives;
  document.getElementById('level').textContent = level;
}

function restartGame() {
  score = 0;
  lives = 3;
  level = 1;
  bullets = [];
  enemyBullets = [];
  explosions = [];
  gameRunning = true;
  createEnemies();
  startRespawn();
  updateInfo();
  document.getElementById('gameOver').style.display = 'none';
}

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') shoot();
  if (e.code === 'KeyR') restartGame();
});
document.addEventListener('keyup', e => keys[e.code] = false);

initSounds();
createEnemies();
startRespawn();
updateInfo();
(function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
